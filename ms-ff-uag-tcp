#!/usr/bin/env python3

# ToDo: init methods
# ToDo: clean up methods
# ToDo: clean connection close
# ToDo: multiple connections?
# ToDo: ditch all blocking op
# ToDo: ignore redirect

import asyncio

from collections import OrderedDict
from requests_toolbelt import MultipartEncoder

try:
    import signal
except ImportError:
    signal = None
import logging
    
import urllib.request, ssl
from urllib.parse import urljoin, quote
from http.cookiejar import CookieJar, DefaultCookiePolicy

from bs4 import BeautifulSoup

import re
import sys
import argparse
from pprint import pprint
import os.path

import datetime
import random

log = logging.getLogger(__name__)
uag_session = None

BUFFER_SIZE = 1024*768
NEXT_TICK = 0.01


ARGS = argparse.ArgumentParser(description="ms-ff-uag-tcp")
USER_AGENT = ("Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 "
    "(KHTML, like Gecko) Chrome/50.0.2661.75 Safari/537.36") # modern UA, otherwise it thinks i'm on mobile

ACCEPT = "*/*"
ALLOW_REDIRECT = True


ARGS.add_argument(
    '--domain', action="store", dest='domain',
    default='localhost', type=str, help='Domain of MS ForeFront UAG')

ARGS.add_argument(
    '--cafile', action="store", dest='cafile',
    default='creds/cacert.pem', type=str, help='Certificate chain for the UAG https')

ARGS.add_argument(
    '--auth', action="store", dest='auth',
    default='creds/auth.txt', type=str, 
    help='Username and password in plaintext separated by a new line')

ARGS.add_argument(
    '--dir', action="store", dest='dir',
    default='', type=str, help='Directory in MS FF')


ARGS.add_argument(
    '--server', action="store", dest='server',
    type=str, help='Server mode: connect to that address')

ARGS.add_argument(
    '--client', action="store", dest='client',
    type=str, help='Client mode: listen to address for connections')


ARGS.add_argument(
    '--quiet', action="store", dest='quiet',
    default=0, type=int, help="Don't show debug info")

class Address:
    host = None
    port = None

    def __new__(cls, addr):
        try:
            addr = addr.split(":")
            host = addr[0]
            port = int(addr[1])
            return super(Address, cls).__new__(cls)
        except (AttributeError, KeyError) as e:
            return None

    def __init__(self, addr):
        addr = addr.split(":")
        self.host = addr[0]
        self.port = int(addr[1])

    def __str__(self):
        return 'Address(host="%s", port=%d)' % (self.host, self.port)

    __repr__ = __str__

        
class UAGSession:
    """Class for working with UAG"""

    opener = None
    home_url = None

    def __init__(self, opener):
        # super(UAGSession, self).__init__()
        self.opener = opener


    def perform_auth(self):
        url = urllib.request.Request("https://" + args.domain + "/")
        url.add_header("User-Agent", USER_AGENT)
        url.add_header("Accept", ACCEPT)

        r = self.opener.open(url)

        login_url = r.url
        html_doc = r.read().decode('utf-8')
        logging.info(login_url)
        # logging.debug(html_doc)

        soup = BeautifulSoup(html_doc, 'html.parser')
        post_url = soup.find(id="form1").get("action")

        uag_dummy_repository = soup.find(id="form1").find("input", {"name": "dummy_repository"}).get("value")
        uag_repository = soup.find(id="form1").find("input", {"name": "repository"}).get("value")

        post_data = {
            "dummy_repository": uag_dummy_repository,
            "repository": uag_repository,
            "user_name": auth_creds.split("\n")[0],
            "password": auth_creds.split("\n")[1],
            "site_name": "fileaccess",
            "secure": "1",
            "resource_id": "2",
            "login_type": "3",
        }

        details = urllib.parse.urlencode(post_data).encode('UTF-8')
        url = urllib.request.Request( urljoin(login_url, post_url) , details)
        url.add_header("User-Agent", USER_AGENT)
        url.add_header("Accept", ACCEPT)

        r = self.opener.open(url)

        html_doc = r.read().decode('utf-8', 'ignore');

        if False:
            new_url = re.search('window\.location\.replace\("([^"]+)"\)', html_doc).group(1)

            logging.info(r.url)
            #logging.debug(html_doc)

            url = urllib.request.Request( urljoin(r.url, new_url))
            url.add_header("User-Agent", USER_AGENT)
            url.add_header("Accept", ACCEPT)

            r = self.opener.open(url)

            html_doc = r.read().decode('utf-8', 'ignore');

        main_url = r.url
        logging.info(r.url)
        # logging.debug(html_doc)

        self.main_url = main_url


    def put_file(self, file, file_content):
        
        folder = args.dir + "/" + file
        folder_escaped = quote(folder, safe='')

        create_folder_url = urljoin(self.main_url, 
            "../filesharing/FileSharingExt/ShareAccessExt.dll?P=" + folder_escaped + "&overwrite=on")

        files = OrderedDict([
            ("Filedata", (file, file_content, 'application/octet-stream') ),
            ("remotefile", args.dir), 
            ("remotefilename", folder.replace('/', '\\').replace('\\\\', '//') ), 
            ("overwrite", "on"),
        ])

        encoder = MultipartEncoder(files)
        body2 = encoder.to_string()

        url = urllib.request.Request(create_folder_url , body2)

        url.add_header("User-Agent", USER_AGENT)
        url.add_header("Accept", ACCEPT)
        url.add_header("Content-Type", encoder.content_type)
        url.add_header("Content-Length", str(len(body2)) )


        try:
            r = self.opener.open(url)
        except urllib.error.HTTPError:
            html_doc = ''
        else:
            pass
            # html_doc = r.read().decode('utf-8', 'ignore');

        #return html_doc
        return b'ok'        

    def create_folder(self, directory):
        
        folder = args.dir + "/" + directory
        folder_escaped = quote(folder, safe='')

        create_folder_url = urljoin(self.main_url, "../filesharing/newfolder.asp?Folder=" + folder_escaped)

        files = OrderedDict([
            ("Filedata", directory ),
            ("remotefile", args.dir), 
            ("submit1", "Create Folder"),
        ])

        encoder = MultipartEncoder(files)
        body2 = encoder.to_string()

        url = urllib.request.Request(create_folder_url , body2)

        url.add_header("User-Agent", USER_AGENT)
        url.add_header("Accept", ACCEPT)
        url.add_header("Content-Type", encoder.content_type)
        url.add_header("Content-Length", str(len(body2)) )

        try:
            r = self.opener.open(url)
        except urllib.error.HTTPError:
            html_doc = ''
        else:
            html_doc = r.read().decode('utf-8', 'ignore');

        return html_doc


    def list_folder(self, directory):
        
        folder = args.dir + "/" + directory
        folder_escaped = quote(folder, safe='')

        create_folder_url = urljoin(self.main_url, "../filesharing/filelist.asp?S=" + folder_escaped + "&T=9")

        url = urllib.request.Request(create_folder_url)

        url.add_header("User-Agent", USER_AGENT)
        url.add_header("Accept", ACCEPT)


        try:
            r = self.opener.open(url)
        except urllib.error.HTTPError:
            return [] # Empty directory
        else:
            html_doc = r.read().decode('utf-8', 'ignore');

        return_arr = []
        try:
            soup = BeautifulSoup(html_doc, 'html.parser')
            file_nodes = soup.find(id="fileListTable").find("tbody").find_all("label")
            for i in file_nodes:
                if i.get("onmousedown").find('isFile = true') != -1:
                    isFile = True
                else:
                    isFile = False

                return_arr.append((isFile, i.find('nobr').text))
        except Exception:
            return_arr = None # Non-existant directory
        return return_arr

    def delete_file(self, file):
        
        folder = args.dir + "/" + file
        folder_escaped = quote(folder, safe='')

        create_folder_url = urljoin(self.main_url, 
            "../filesharing/filelist.asp?S=" + folder_escaped + "&action=1&T=9")

        url = urllib.request.Request(create_folder_url)

        url.add_header("User-Agent", USER_AGENT)
        url.add_header("Accept", ACCEPT)


        try:
            r = self.opener.open(url)
        except urllib.error.HTTPError:
            html_doc = ''
        else:
            html_doc = r.read().decode('utf-8', 'ignore');

        return html_doc

    def get_content(self, file):
        
        folder = args.dir + "/" + file
        folder_escaped = quote(folder, safe='')

        create_folder_url = urljoin(self.main_url, "../filesharing/FileSharingExt/?OPEN&P=" + folder_escaped)

        url = urllib.request.Request(create_folder_url)

        url.add_header("User-Agent", USER_AGENT)
        url.add_header("Accept", ACCEPT)


        try:
            r = self.opener.open(url)
        except urllib.error.HTTPError:
            doc = ''

        doc = r.read(100)

        if doc == '' or doc.decode('cp437','ignore').find("content='0;URL=errorPage.asp?error=404") != -1:
            return (None, None, file)

        return (doc, r, file)


        
def mister_accept_client(client_reader, client_writer):
    if args.server:
        log.error("Something gone terribly wrong")
    log.info("New Connection")
    task = asyncio.ensure_future(mister_communicate_client(client_reader, client_writer))


def future_async(*args):
    return asyncio.ensure_future(loop.run_in_executor(None, *args))


async def scavenge_for_new_tasks(actor, conn, tasks):
    other = "mister" if actor == "valet" else "valet"

    while True:

        listing = await future_async(conn.uagnet.unrecieved_packets, actor) or []

        tasks_id = tasks[len(tasks) - 1][0] + 1

        # We are relying here on UAG alphanumerical sorting

        informal_pip = 0
        for i in listing:
            seq_id = int(i[1].replace('pck-','').replace('.bin',''))

            if seq_id < tasks_id:
                continue

            if seq_id > tasks_id:
                log.error(str(seq_id) +" vs "+str(tasks_id))
                log.error(other+": MISSING SEQ ORDER PACKET. ok...")
                break

            task = future_async(conn.uagnet.commence_packet, actor, tasks_id)
            tasks.append( (tasks_id, task) )

            tasks_id += 1
            informal_pip += 1

        if informal_pip:
            log.info(other+": Scavenger found " +str(informal_pip)+ " pcks")

async def actor_pipe_socket_to_uag(actor, conn):

    index = 1
    sent_data = {}
    kept_data = {}

    while not conn.reader.at_eof():

        while sum(kept_data.values()) > 4 * 1024*1024:

            files = await future_async(conn.uagnet.unrecieved_packets, actor)

            new_sent = {}

            for i in files:
                key = uagNetworkHandle.pck_uri_to_idx(i[1])
                new_sent[key] = sent_data[key]

            kept_data = new_sent

            if sum(kept_data.values()) > 2 * 1024*1024:
                await asyncio.sleep(3.2)


        log.debug(actor+': waiting for a read from server')

        data = await conn.reader.read(BUFFER_SIZE)

        if conn.reader.at_eof():
            data = b'!' + data
        else:
            data = b' ' + data

        log.debug(actor+': got a read from server')
        log.debug(actor+': sending data to MISTER %r (%d b) ' % (data, len(data)))

        future_async(conn.uagnet.send_packet, actor, index, data)

        log.info(actor+': putting index %d as %d b' % (index, len(data)))

        kept_data[index] = len(data)
        sent_data[index] = len(data)

        index += 1

    log.warn(actor+': reader closed')


async def actor_pipe_uag_to_socket(actor, conn):

    other = "mister" if actor == "valet" else "valet"

    index = 1
    first_time = True
    tasks = []
    while True:

        # ------ assyming blocking behaviour
        del tasks[:]
        task = future_async(conn.uagnet.commence_packet, actor, index)
        tasks.append( (index, task) )
        # ------ assyming blocking behaviour

        if first_time:
            asyncio.ensure_future( scavenge_for_new_tasks(actor, conn, tasks) )
            first_time = False

        log.debug(other+": starting ordered parallelism")
        for task in tasks:
            data, r, url = await task[1]

            if data is not None:
                log.debug(other+': got data from VALET "%r" (%d b)' % (data, len(data)))
                log.debug(other+': relaying VALETS data')

                if data[0] == b'!'[0]:
                    conn.writer.write_eof()
                    # TODO: should be break(2), 
                    break

                else:
                    conn.writer.write(data[1:])

                    while True:
                        doc = await future_async(r.read, 16*1024)
                        if not doc:
                            break
                        conn.writer.write(doc)
                
                future_async(conn.uagnet.ack_packet, actor, index)

                index += 1
            else:
                log.debug(other+": when polling uag, data was None")

        await asyncio.sleep(NEXT_TICK) 

    log.warn(other+': writer closed')






async def mister_communicate_client(client_reader, client_writer):

    conn = connectionHandle(uagNetworkHandle(uag_session))
    conn.writer = client_writer
    conn.reader = client_reader
    conn.uagnet.token = uagNetworkHandle.gen_token()
    conn.uagnet.do_syn()

    task = asyncio.ensure_future(actor_pipe_uag_to_socket('valet', conn))

    while True:
        data = conn.uagnet.lookup_synack()

        if data is None:
            log.info("data is None")
            await asyncio.sleep(NEXT_TICK)
            continue
        
        if (False, "line-mister") in data:
            pprint(data)
            log.info("connection established!!")
            break
        else:
            log.info("waiting to synack from server")

        await asyncio.sleep(NEXT_TICK)
    
    await actor_pipe_socket_to_uag("mister", conn)


async def valet_communicate_server():

    # server is capable of only one connection at a time.
    while True:

        delayed_open = None

        conn = connectionHandle(uagNetworkHandle(uag_session))

        while True:
            data = conn.uagnet.lookup_syns()

            if len(data):
                conn.uagnet.token = uagNetworkHandle.conn_uri_to_token(data[0][1])

                delayed_open = asyncio.ensure_future(asyncio.open_connection(
                    args.server.host, args.server.port))               

                conn.uagnet.do_synack()
                break

            await asyncio.sleep(NEXT_TICK)

        log.info("VALET: new connection from MISTER %s" % conn.uagnet.token)
        
        conn.reader, conn.writer = await delayed_open

        log.info("VALET: established server conn for %s" % conn.uagnet.token)

        asyncio.ensure_future(actor_pipe_uag_to_socket('mister', conn))
        await actor_pipe_socket_to_uag("valet", conn)

class connectionHandle:
    uagnet = None
    
    reader = None
    writer = None

    def __init__(self, uagnet):
        self.uagnet = uagnet


class uagNetworkHandle:

    token = ''
    uag = None

    def __init__(self, uag):
        self.uag = uag

    @staticmethod
    def pck_uri(token, line, idx):
        return ".ms-ff-uag-tcp-data/%s-est/line-%s/pck-%s.bin" % (token, line, str(idx).zfill(8))

    @staticmethod
    def pck_uri_to_idx(uri):
        return int(os.path.basename(uri).replace('pck-','').replace('.bin',''))

    @staticmethod
    def conn_uri_to_token(uri):
        return os.path.basename(uri).replace('.con', '')

    @staticmethod
    def gen_token():
        return datetime.datetime.now().strftime("%H_%M-%d-%m-%Y_") + ('%08X' % random.randrange(16**8))

    def do_syn(self):
        self.uag.put_file(".ms-ff-uag-tcp-data/to-connect/%s.con" % self.token, b'')

    def lookup_syns(self):
        return self.uag.list_folder(".ms-ff-uag-tcp-data/to-connect/")

    def do_synack(self):
        self.uag.create_folder(".ms-ff-uag-tcp-data/%s-est" % self.token) 
        self.uag.create_folder(".ms-ff-uag-tcp-data/%s-est/line-mister" % self.token)
        self.uag.create_folder(".ms-ff-uag-tcp-data/%s-est/line-valet" % self.token) 
        self.uag.delete_file(".ms-ff-uag-tcp-data/to-connect/%s.con" % self.token)

    def lookup_synack(self):
        return self.uag.list_folder(".ms-ff-uag-tcp-data/%s-est/" % self.token)

    def commence_packet(self, line, idx):
        return self.uag.get_content(uagNetworkHandle.pck_uri(self.token, line, idx))

    def send_packet(self, line, idx, packet):
        self.uag.put_file(uagNetworkHandle.pck_uri(self.token, line, idx), packet)

    def unrecieved_packets(self, line):
        return self.uag.list_folder(".ms-ff-uag-tcp-data/%s-est/line-%s" % (self.token, line))

    def ack_packet(self, line, idx):
        self.uag.delete_file(uagNetworkHandle.pck_uri(self.token, line, idx))


class NoRedirect(urllib.request.HTTPRedirectHandler):
    def redirect_request(self, req, fp, code, msg, hdrs, newurl):
        if ALLOW_REDIRECT:
            return urllib.request.HTTPRedirectHandler.redirect_request(self, req, fp, code, msg, hdrs, newurl)
        else:
            return None

from collections import namedtuple


if __name__ == '__main__':

    log = logging.getLogger("")
    formatter = logging.Formatter("%(asctime)s %(levelname)s " +
                                  "[%(module)s:%(lineno)d] %(message)s")
    # setup console logging

    args = ARGS.parse_args()
    with open(args.auth, 'r') as args.auth:
        auth_creds = args.auth.read()

    args.server = Address(args.server)
    args.client = Address(args.client)

    if args.quiet == 2:
        log.error('Logging error only')
        lvl = logging.ERROR
    elif args.quiet == 1:
        log.info('Logging info')
        lvl = logging.INFO
    elif args.quiet == 0:
        log.info('Logging debug')
        lvl = logging.DEBUG

    log.setLevel(lvl)
    ch = logging.StreamHandler()
    ch.setLevel(lvl)

    ch.setFormatter(formatter)
    log.addHandler(ch)
    

    ctx = ssl.create_default_context(cafile=args.cafile)
    cj = CookieJar(DefaultCookiePolicy(rfc2965=True, 
        strict_ns_domain=DefaultCookiePolicy.DomainStrict, blocked_domains=["ads.net", ".ads.net"]))
    opener = urllib.request.build_opener(urllib.request.HTTPSHandler(context=ctx), 
        urllib.request.HTTPCookieProcessor(cj),
        NoRedirect())



    uag_session = UAGSession(opener)
    uag_session.perform_auth()
    ALLOW_REDIRECT = False

    loop = asyncio.get_event_loop()

    if signal is not None and sys.platform != 'win32':
        loop.add_signal_handler(signal.SIGINT, loop.stop)


    if args.server:
        f = asyncio.ensure_future(valet_communicate_server())
        log.info("Waiting for connection request")
    else:
        f = asyncio.start_server(mister_accept_client, host=args.client.host, port=args.client.port)
        log.info("Server is listening on port 8000")

    loop.run_until_complete(f)
    loop.run_forever()
    



    # Unit tests would be of use
    # create_folder(opener, main_url, 'testing-folders')
    # pprint(list_folder(opener, main_url, ''))
    # pprint(get_content(opener, main_url, 'ms-ff-uag-tcp.md'))
    # put_file(opener, main_url, '00000000.bin', b'SSH-2.0-OpenSSH_6.7p1 Debian-5+deb8u2\r\n')
    # delete_file(opener, main_url, 'testing-132-folders')
    
