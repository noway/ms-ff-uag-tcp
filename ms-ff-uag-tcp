#!/usr/bin/env python3

# ToDo: init methods
# ToDo: clean up methods
# ToDo: multiple connections?

import asyncio

try:
    import signal
except ImportError:
    signal = None

from collections import OrderedDict
from collections import namedtuple

import re
import sys
import os.path
import datetime
import random

import logging
import argparse

import urllib.request
import ssl

from urllib.parse import urljoin
from urllib.parse import quote

from http.cookiejar import CookieJar
from http.cookiejar import DefaultCookiePolicy

from bs4 import BeautifulSoup

from requests_toolbelt import MultipartEncoder
from keepalive import HTTPHandler


log = logging.getLogger(__name__)

# sys.setcheckinterval(0)

ALARM_GARBAGE_SIZE = 1024*1024*4
BIG_GARBAGE_SIZE = 1024*1024*2

BUFFER_SIZE = 1024*768
SMALL_BUFFER_SIZE = 1024*64
NEXT_TICK = 0.01


ARGS = argparse.ArgumentParser(description="ms-ff-uag-tcp")

# modern UA, otherwise it thinks i'm on mobile
USER_AGENT = ("Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 "
              "(KHTML, like Gecko) Chrome/50.0.2661.75 Safari/537.36")

ACCEPT = "*/*"
ALLOW_REDIRECT = True


ARGS.add_argument(
    '--domain', action="store", dest='domain', default='localhost',
    type=str, help='Domain of MS ForeFront UAG')

ARGS.add_argument(
    '--cafile', action="store", dest='cafile', default='creds/cacert.pem',
    type=str, help='Certificate chain for UAG https')

ARGS.add_argument(
    '--auth', action="store", dest='auth', default='creds/auth.txt', type=str,
    help='Username and password in plaintext separated by a new line')

ARGS.add_argument(
    '--dir', action="store", dest='dir', default='',
    type=str, help='Directory in MS FF')

ARGS.add_argument(
    '--server', action="store", dest='server',
    type=str, help='Server mode: connect to that address')

ARGS.add_argument(
    '--client', action="store", dest='client',
    type=str, help='Client mode: listen to address for connections')


ARGS.add_argument(
    '--quiet', action="store", dest='quiet',
    default=0, type=int, help="Don't show debug info")


class NoRedirect(urllib.request.HTTPRedirectHandler):
    def redirect_request(self, req, fp, code, msg, hdrs, newurl):
        if ALLOW_REDIRECT:
            return urllib.request.HTTPRedirectHandler.redirect_request(
                self, req, fp, code, msg, hdrs, newurl)
        else:
            return None


PckTask = namedtuple('PckTask', 'idx, task')


ListDir = namedtuple('ListDir', 'is_file, name')


class Address:
    host = None
    port = None

    def __new__(cls, addr):
        try:
            addr = addr.split(":")
            host = addr[0]
            port = int(addr[1])
            return super(Address, cls).__new__(cls)
        except (AttributeError, KeyError) as e:
            return None

    def __init__(self, addr):
        addr = addr.split(":")
        self.host = addr[0]
        self.port = int(addr[1])

    def __str__(self):
        return 'Address(host="%s", port=%d)' % (self.host, self.port)

    __repr__ = __str__


class connectionHandle:
    uagnet = None

    reader = None
    writer = None

    is_connected_or_connecting = False

    def __init__(self, uagnet):
        self.uagnet = uagnet


class uagNetworkHandle:

    token = ''
    uag = None

    def __init__(self, uag):
        self.uag = uag

    @staticmethod
    def pck_uri(token, line, idx):
        return ".ms-ff-uag-tcp-data/%s-est/line-%s/pck-%s.bin" % (
            token, line, str(idx).zfill(8))

    @staticmethod
    def pck_uri_to_idx(uri):
        return int(os.path.basename(uri).replace(
            'pck-', '').replace('.bin', ''))

    @staticmethod
    def conn_uri_to_token(uri):
        return os.path.basename(uri).replace('.con', '')

    @staticmethod
    def gen_token():
        return datetime.datetime.now().strftime("%H_%M-%d-%m-%Y_") + (
            '%08X' % random.randrange(16**8))

    def do_syn(self):
        self.uag.put_file(
            ".ms-ff-uag-tcp-data/to-connect/%s.con" % self.token, b'')

    def lookup_syns(self):
        return self.uag.list_folder(".ms-ff-uag-tcp-data/to-connect/")

    def do_synack(self):
        self.uag.create_folder(
            ".ms-ff-uag-tcp-data/%s-est" % self.token)
        self.uag.create_folder(
            ".ms-ff-uag-tcp-data/%s-est/line-mister" % self.token)
        self.uag.create_folder(
            ".ms-ff-uag-tcp-data/%s-est/line-valet" % self.token)
        self.uag.delete_file(
            ".ms-ff-uag-tcp-data/to-connect/%s.con" % self.token)

    def lookup_synack(self):
        return self.uag.list_folder(
            ".ms-ff-uag-tcp-data/%s-est/" % self.token)

    def commence_packet(self, line, idx):
        return self.uag.get_content(
            uagNetworkHandle.pck_uri(self.token, line, idx))

    def send_packet(self, line, idx, packet):
        self.uag.put_file(
            uagNetworkHandle.pck_uri(self.token, line, idx), packet)

    def unrecieved_packets(self, line):
        return self.uag.list_folder(
            ".ms-ff-uag-tcp-data/%s-est/line-%s" % (self.token, line))

    def ack_packet(self, line, idx):
        self.uag.delete_file(uagNetworkHandle.pck_uri(self.token, line, idx))


class UAGSession:
    """Class for working with UAG"""

    opener = None
    home_url = None

    def __init__(self, opener):
        # super(UAGSession, self).__init__()
        self.opener = opener

    def perform_auth(self):
        url = urllib.request.Request("https://" + args.domain + "/")
        url.add_header("User-Agent", USER_AGENT)
        url.add_header("Accept", ACCEPT)

        r = self.opener.open(url)

        login_url = r.url
        html_doc = r.read().decode('utf-8')
        logging.info(login_url)
        # logging.debug(html_doc)

        soup = BeautifulSoup(html_doc, 'html.parser')
        post_url = soup.find(id="form1").get("action")

        uag_dummy_repository = soup.find(id="form1").find(
            "input", {"name": "dummy_repository"}).get("value")

        uag_repository = soup.find(id="form1").find(
            "input", {"name": "repository"}).get("value")

        post_data = {
            "dummy_repository": uag_dummy_repository,
            "repository": uag_repository,
            "user_name": auth_creds.split("\n")[0],
            "password": auth_creds.split("\n")[1],
            "site_name": "fileaccess",
            "secure": "1",
            "resource_id": "2",
            "login_type": "3",
        }

        details = urllib.parse.urlencode(post_data).encode('UTF-8')
        url = urllib.request.Request(urljoin(login_url, post_url), details)
        url.add_header("User-Agent", USER_AGENT)
        url.add_header("Accept", ACCEPT)

        r = self.opener.open(url)

        html_doc = r.read().decode('utf-8', 'ignore')

        if False:
            new_url = re.search(
                'window\.location\.replace\("([^"]+)"\)', html_doc).group(1)

            logging.info(r.url)
            # logging.debug(html_doc)

            url = urllib.request.Request(urljoin(r.url, new_url))
            url.add_header("User-Agent", USER_AGENT)
            url.add_header("Accept", ACCEPT)

            r = self.opener.open(url)

            html_doc = r.read().decode('utf-8', 'ignore')

        main_url = r.url
        logging.info(r.url)
        # logging.debug(html_doc)

        self.main_url = main_url

    def put_file(self, file, file_content):

        folder = args.dir + "/" + file
        folder_escaped = quote(folder, safe='')
        folder_canonical = folder.replace('/', '\\').replace('\\\\', '//')

        create_folder_url = urljoin(
            self.main_url,
            "../filesharing/FileSharingExt/ShareAccessExt.dll?P=" +
            folder_escaped + "&overwrite=on")

        files = OrderedDict([
            ("Filedata", (file, file_content, 'application/octet-stream')),
            ("remotefile", args.dir),
            ("remotefilename", folder_canonical),
            ("overwrite", "on"),
        ])

        encoder = MultipartEncoder(files)
        body2 = encoder.to_string()

        url = urllib.request.Request(create_folder_url, body2)

        url.add_header("User-Agent", USER_AGENT)
        url.add_header("Accept", ACCEPT)
        url.add_header("Content-Type", encoder.content_type)
        url.add_header("Content-Length", str(len(body2)))

        try:
            r = self.opener.open(url)
        except urllib.error.HTTPError:
            html_doc = ''
        else:
            pass
            # html_doc = r.read().decode('utf-8', 'ignore')

        # return html_doc
        return b'ok'

    def create_folder(self, directory):

        folder = args.dir + "/" + directory
        folder_escaped = quote(folder, safe='')

        create_folder_url = urljoin(
            self.main_url,
            "../filesharing/newfolder.asp?Folder=" + folder_escaped)

        files = OrderedDict([
            ("Filedata", directory),
            ("remotefile", args.dir),
            ("submit1", "Create Folder"),
        ])

        encoder = MultipartEncoder(files)
        body2 = encoder.to_string()

        url = urllib.request.Request(create_folder_url, body2)

        url.add_header("User-Agent", USER_AGENT)
        url.add_header("Accept", ACCEPT)
        url.add_header("Content-Type", encoder.content_type)
        url.add_header("Content-Length", str(len(body2)))

        try:
            r = self.opener.open(url)
        except urllib.error.HTTPError:
            html_doc = ''
        else:
            html_doc = r.read().decode('utf-8', 'ignore')

        return html_doc

    def list_folder(self, directory):

        folder = args.dir + "/" + directory
        folder_escaped = quote(folder, safe='')

        create_folder_url = urljoin(
            self.main_url,
            "../filesharing/filelist.asp?S=" + folder_escaped + "&T=9")

        url = urllib.request.Request(create_folder_url)

        url.add_header("User-Agent", USER_AGENT)
        url.add_header("Accept", ACCEPT)

        try:
            r = self.opener.open(url)
        except urllib.error.HTTPError:
            return []  # Empty directory
        else:
            html_doc = r.read().decode('utf-8', 'ignore')

        results = []
        try:
            soup = BeautifulSoup(html_doc, 'html.parser')
            file_nodes = soup.find(id="fileListTable").find(
                "tbody").find_all("label")
            for i in file_nodes:
                if i.get("onmousedown").find('isFile = true') != -1:
                    isFile = True
                else:
                    isFile = False

                results.append(ListDir(isFile, i.find('nobr').text))
        except Exception:
            results = None  # Non-existant directory

        return results

    def delete_file(self, file):

        folder = args.dir + "/" + file
        folder_escaped = quote(folder, safe='')

        create_folder_url = urljoin(
            self.main_url,
            "../filesharing/filelist.asp?S=" + folder_escaped +
            "&action=1&T=9")

        url = urllib.request.Request(create_folder_url)

        url.add_header("User-Agent", USER_AGENT)
        url.add_header("Accept", ACCEPT)

        try:
            r = self.opener.open(url)
        except urllib.error.HTTPError:
            html_doc = ''
        else:
            html_doc = r.read().decode('utf-8', 'ignore')

        return html_doc

    def get_content(self, file):

        folder = args.dir + "/" + file
        folder_escaped = quote(folder, safe='')

        create_folder_url = urljoin(
            self.main_url,
            "../filesharing/FileSharingExt/?OPEN&P=" + folder_escaped)

        url = urllib.request.Request(create_folder_url)

        url.add_header("User-Agent", USER_AGENT)
        url.add_header("Accept", ACCEPT)

        try:
            r = self.opener.open(url)
            doc = r.read(100)
            doc_text = doc.decode('cp437', 'ignore')
            is_404 = doc_text.find("content='0;URL=errorPage.asp?error=404")
        except urllib.error.HTTPError:
            doc = ''
            doc_text = ''
            is_404 = 1

        if doc == '' or is_404 != -1:
            return (None, None, file)

        return (doc, r, file)


def future_async(*args):
    return asyncio.ensure_future(loop.run_in_executor(None, *args))


async def scavenge_for_new_tasks(actor, conn, tasks):
    other = "mister" if actor == "valet" else "valet"

    while conn.is_connected_or_connecting:

        listing = await future_async(
            conn.uagnet.unrecieved_packets, actor) or []

        tasks_id = tasks[len(tasks) - 1].idx + 1

        # We are relying here on UAG alphanumerical sorting

        informal_pip = 0
        for i in listing:
            seq_id = uagNetworkHandle.pck_uri_to_idx(i.name)

            if seq_id < tasks_id:
                continue

            if seq_id > tasks_id:
                log.error("%d vs %d" % (seq_id, tasks_id))
                log.error(other+": MISSING SEQ ORDER PACKET. ok...")
                break

            task = future_async(conn.uagnet.commence_packet, actor, tasks_id)
            tasks.append(PckTask(tasks_id, task))

            tasks_id += 1
            informal_pip += 1

            if informal_pip > 5:
                # rate limit
                break

        if informal_pip:
            log.info(other + ": Scavenger found %d pcks" % informal_pip)

        await asyncio.sleep(0.67)

async def actor_pipe_socket_to_uag(actor, conn):

    idx = 1
    sent_data = {}
    kept_data = {}

    while not conn.reader.at_eof():

        while sum(kept_data.values()) > ALARM_GARBAGE_SIZE:

            files = await future_async(conn.uagnet.unrecieved_packets, actor)

            new_sent = {}

            for i in files:
                key = uagNetworkHandle.pck_uri_to_idx(i.name)
                new_sent[key] = sent_data[key]

            kept_data = new_sent

            if sum(kept_data.values()) > BIG_GARBAGE_SIZE:
                await asyncio.sleep(3.2)

        log.debug(actor+': waiting for a read from server')

        data = await conn.reader.read(BUFFER_SIZE)

        if conn.reader.at_eof():
            data = b'!' + data
        else:
            data = b' ' + data

        log.debug(actor+': got a read from server')
        log.debug(actor+': sending data to MISTER %r (%d b) ' % (
            data, len(data)))

        future_async(conn.uagnet.send_packet, actor, idx, data)

        log.info(actor+': putting idx %d as %d b' % (idx, len(data)))

        kept_data[idx] = len(data)
        sent_data[idx] = len(data)

        idx += 1

    log.warn(actor+': reader closed')
    conn.is_connected_or_connecting = False


async def actor_pipe_uag_to_socket(actor, conn):

    other = "mister" if actor == "valet" else "valet"

    idx = 1
    first_time = True
    tasks = []
    wrote_eof = False

    while conn.is_connected_or_connecting and not wrote_eof:

        # ------ assyming blocking behaviour
        del tasks[:]
        task = future_async(conn.uagnet.commence_packet, actor, idx)
        tasks.append(PckTask(idx, task))
        # ------ assyming blocking behaviour

        if first_time:
            asyncio.ensure_future(scavenge_for_new_tasks(actor, conn, tasks))
            first_time = False

        log.debug(other+": starting ordered parallelism")
        for task in tasks:  # no race cond here?
            data, r, url = await task.task

            if data is not None:
                log.debug(other+': got data from VALET "%r" (%d b)' % (
                    data, len(data)))
                log.debug(other+': relaying VALETS data')

                if data[0] == b'!'[0]:
                    conn.writer.write_eof()
                    wrote_eof = True
                    break

                else:
                    conn.writer.write(data[1:])
                    dlen = 100
                    while True:
                        doc = await future_async(r.read, SMALL_BUFFER_SIZE)
                        conn.writer.write(doc)
                        if not doc:
                            break
                        dlen += len(doc)

                    log.info(other+": feeded %d as %d b" % (idx, dlen))

                future_async(conn.uagnet.ack_packet, actor, idx)

                idx += 1
            else:
                log.debug(other+": when polling uag, data was None")
                await asyncio.sleep(NEXT_TICK)

        # await asyncio.sleep(NEXT_TICK)

    log.warn(other+': writer closed')


async def mister_contact_client(uag, client_reader, client_writer):

    log.info("New Connection")

    conn = connectionHandle(uagNetworkHandle(uag))
    conn.writer = client_writer
    conn.reader = client_reader
    conn.uagnet.token = uagNetworkHandle.gen_token()
    await future_async(conn.uagnet.do_syn)

    conn.is_connected_or_connecting = True

    task = asyncio.ensure_future(actor_pipe_uag_to_socket('valet', conn))

    while True:
        data = await future_async(conn.uagnet.lookup_synack)

        if data is None:
            log.info("data is None")
            # await asyncio.sleep(NEXT_TICK)
            continue

        if ListDir(False, "line-mister") in data:
            log.info("Connection established!")
            break
        else:
            log.info("Waiting to synack from server")

        # await asyncio.sleep(NEXT_TICK)

    await actor_pipe_socket_to_uag("mister", conn)


async def valet_contact_server(uag):

    # server is capable of only one connection at a time.
    while True:

        delayed_open = None

        conn = connectionHandle(uagNetworkHandle(uag))

        while True:
            data = await future_async(conn.uagnet.lookup_syns)

            if len(data):
                conn.uagnet.token = uagNetworkHandle.conn_uri_to_token(
                    data[0].name)

                conn.is_connected_or_connecting = True

                delayed_open = asyncio.ensure_future(asyncio.open_connection(
                    args.server.host, args.server.port))

                await future_async(conn.uagnet.do_synack)
                break

            # await asyncio.sleep(NEXT_TICK)

        log.info("VALET: new connection from MISTER %s" % conn.uagnet.token)

        conn.reader, conn.writer = await delayed_open

        log.info("VALET: established server conn for %s" % conn.uagnet.token)

        asyncio.ensure_future(actor_pipe_uag_to_socket('mister', conn))
        await actor_pipe_socket_to_uag("valet", conn)


if __name__ == '__main__':

    log = logging.getLogger("")
    formatter = logging.Formatter("%(asctime)s %(levelname)s " +
                                  "[%(module)s:%(lineno)d] %(message)s")
    # setup console logging

    args = ARGS.parse_args()
    with open(args.auth, 'r') as args.auth:
        auth_creds = args.auth.read()

    args.server = Address(args.server)
    args.client = Address(args.client)

    if args.quiet == 2:
        log.error('Logging error only')
        lvl = logging.ERROR
    elif args.quiet == 1:
        log.info('Logging info')
        lvl = logging.INFO
    elif args.quiet == 0:
        log.info('Logging debug')
        lvl = logging.DEBUG

    log.setLevel(lvl)
    ch = logging.StreamHandler()
    ch.setLevel(lvl)

    ch.setFormatter(formatter)
    log.addHandler(ch)

    ctx = ssl.create_default_context(cafile=args.cafile)
    cj = CookieJar(
        DefaultCookiePolicy(
            rfc2965=True,
            strict_ns_domain=DefaultCookiePolicy.DomainStrict,
            blocked_domains=["ads.net", ".ads.net"]))

    opener = urllib.request.build_opener(
        urllib.request.HTTPSHandler(context=ctx),
        HTTPHandler(),
        urllib.request.HTTPCookieProcessor(cj),
        NoRedirect())

    uag = UAGSession(opener)
    uag.perform_auth()
    ALLOW_REDIRECT = False

    loop = asyncio.get_event_loop()

    if signal is not None and sys.platform != 'win32':
        loop.add_signal_handler(signal.SIGINT, loop.stop)

    if args.server:
        f = asyncio.ensure_future(valet_contact_server(uag))
        log.info("Waiting for connection request")
    else:
        f = asyncio.start_server(
            lambda r, w: asyncio.ensure_future(
                mister_contact_client(uag, r, w)),
            host=args.client.host, port=args.client.port)
        log.info("Server is listening on port 8000")

    loop.run_until_complete(f)
    loop.run_forever()

    # Unit tests would be of use
    # create_folder(opener, main_url, 'testing-folders')
    # pprint(list_folder(opener, main_url, ''))
    # pprint(get_content(opener, main_url, 'ms-ff-uag-tcp.md'))
    # put_file(opener, main_url, '00000000.bin', b'test')
    # delete_file(opener, main_url, 'testing-132-folders')
